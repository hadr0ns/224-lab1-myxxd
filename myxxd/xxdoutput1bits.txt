00000000: 00100011 01101001 01101110 01100011 01101100 01110101  #inclu
00000006: 01100100 01100101 00100000 00111100 01110011 01110100  de <st
0000000c: 01100100 01101001 01101111 00101110 01101000 00111110  dio.h>
00000012: 00001010 00100011 01101001 01101110 01100011 01101100  .#incl
00000018: 01110101 01100100 01100101 00100000 00111100 01110011  ude <s
0000001e: 01110100 01100100 01101100 01101001 01100010 00101110  tdlib.
00000024: 01101000 00111110 00001010 00100011 01101001 01101110  h>.#in
0000002a: 01100011 01101100 01110101 01100100 01100101 00100000  clude 
00000030: 00111100 01110011 01110100 01110010 01101001 01101110  <strin
00000036: 01100111 00101110 01101000 00111110 00001010 00001010  g.h>..
0000003c: 00100011 01100100 01100101 01100110 01101001 01101110  #defin
00000042: 01100101 00100000 01010100 01010010 01010101 01000101  e TRUE
00000048: 00100000 00110001 00001010 00100011 01100100 01100101   1.#de
0000004e: 01100110 01101001 01101110 01100101 00100000 01000110  fine F
00000054: 01000001 01001100 01010011 01000101 00100000 00110000  ALSE 0
0000005a: 00001010 00100011 01100100 01100101 01100110 01101001  .#defi
00000060: 01101110 01100101 00100000 01000010 01000001 01000100  ne BAD
00000066: 01011111 01001110 01010101 01001101 01000010 01000101  _NUMBE
0000006c: 01010010 01011111 01000001 01010010 01000111 01010011  R_ARGS
00000072: 00100000 00110001 00001010 00001010 00101111 00101010   1../*
00000078: 00101010 00001010 00100000 00101010 00100000 01010000  *. * P
0000007e: 01100001 01110010 01110011 01100101 01110011 00100000  arses 
00000084: 01110100 01101000 01100101 00100000 01100011 01101111  the co
0000008a: 01101101 01101101 01100001 01101110 01100100 00100000  mmand 
00000090: 01101100 01101001 01101110 01100101 00101110 00001010  line..
00000096: 00100000 00101010 00001010 00100000 00101010 00100000   *. * 
0000009c: 01100001 01110010 01100111 01100011 00111010 00100000  argc: 
000000a2: 01110100 01101000 01100101 00100000 01101110 01110101  the nu
000000a8: 01101101 01100010 01100101 01110010 00100000 01101111  mber o
000000ae: 01100110 00100000 01101001 01110100 01100101 01101101  f item
000000b4: 01110011 00100000 01101111 01101110 00100000 01110100  s on t
000000ba: 01101000 01100101 00100000 01100011 01101111 01101101  he com
000000c0: 01101101 01100001 01101110 01100100 00100000 01101100  mand l
000000c6: 01101001 01101110 01100101 00100000 00101000 01100001  ine (a
000000cc: 01101110 01100100 00100000 01101100 01100101 01101110  nd len
000000d2: 01100111 01110100 01101000 00100000 01101111 01100110  gth of
000000d8: 00100000 01110100 01101000 01100101 00001010 00100000   the. 
000000de: 00101010 00100000 00100000 00100000 00100000 00100000  *     
000000e4: 00100000 00100000 01100001 01110010 01100111 01110110    argv
000000ea: 00100000 01100001 01110010 01110010 01100001 01111001   array
000000f0: 00101001 00100000 01101001 01101110 01100011 01101100  ) incl
000000f6: 01110101 01100100 01101001 01101110 01100111 00100000  uding 
000000fc: 01110100 01101000 01100101 00100000 01100101 01111000  the ex
00000102: 01100101 01100011 01110101 01110100 01100001 01100010  ecutab
00000108: 01101100 01100101 00001010 00100000 00101010 00100000  le. * 
0000010e: 01100001 01110010 01100111 01110110 00111010 00100000  argv: 
00000114: 01110100 01101000 01100101 00100000 01100001 01110010  the ar
0000011a: 01110010 01100001 01111001 00100000 01101111 01100110  ray of
00000120: 00100000 01100001 01110010 01100111 01110101 01101101   argum
00000126: 01100101 01101110 01110100 01110011 00100000 01100001  ents a
0000012c: 01110011 00100000 01110011 01110100 01110010 01101001  s stri
00000132: 01101110 01100111 01110011 00100000 00101000 01100011  ngs (c
00000138: 01101000 01100001 01110010 00101010 00100000 01100001  har* a
0000013e: 01110010 01110010 01100001 01111001 00101001 00001010  rray).
00000144: 00100000 00101010 00100000 01100010 01101001 01110100   * bit
0000014a: 01110011 00111010 00100000 01110100 01101000 01100101  s: the
00000150: 00100000 01101001 01101110 01110100 01100101 01100111   integ
00000156: 01100101 01110010 00100000 01110110 01100001 01101100  er val
0000015c: 01110101 01100101 00100000 01101001 01110011 00100000  ue is 
00000162: 01110011 01100101 01110100 00100000 01110100 01101111  set to
00000168: 00100000 01010100 01010010 01010101 01000101 00100000   TRUE 
0000016e: 01101001 01100110 00100000 01100010 01101001 01110100  if bit
00000174: 01110011 00100000 01101111 01110101 01110100 01110000  s outp
0000017a: 01110101 01110100 00100000 01101001 01101110 01100100  ut ind
00000180: 01101001 01100011 01100001 01110100 01100101 01100100  icated
00000186: 00001010 00100000 00101010 00100000 00100000 00100000  . *   
0000018c: 00100000 00100000 00100000 00100000 01101111 01110101      ou
00000192: 01110100 01101000 01100101 01110010 01110111 01101001  therwi
00000198: 01110011 01100101 00100000 01000110 01000001 01001100  se FAL
0000019e: 01010011 01000101 00100000 01100110 01101111 01110010  SE for
000001a4: 00100000 01101000 01100101 01111000 00100000 01101111   hex o
000001aa: 01110101 01110100 01110000 01110101 01110100 00001010  utput.
000001b0: 00100000 00101010 00001010 00100000 00101010 00100000   *. * 
000001b6: 01110010 01100101 01110100 01110101 01110010 01101110  return
000001bc: 01110011 00100000 01110100 01101000 01100101 00100000  s the 
000001c2: 01101001 01101110 01110000 01110101 01110100 00100000  input 
000001c8: 01100110 01101001 01101100 01100101 00100000 01110000  file p
000001ce: 01101111 01101001 01101110 01110100 01100101 01110010  ointer
000001d4: 00100000 00101000 01000110 01001001 01001100 01000101   (FILE
000001da: 00101010 00101001 00001010 00100000 00101010 00101010  *). **
000001e0: 00101111 00001010 01000110 01001001 01001100 01000101  /.FILE
000001e6: 00100000 00101010 01110000 01100001 01110010 01110011   *pars
000001ec: 01100101 01000011 01101111 01101101 01101101 01100001  eComma
000001f2: 01101110 01100100 01001100 01101001 01101110 01100101  ndLine
000001f8: 00101000 01101001 01101110 01110100 00100000 01100001  (int a
000001fe: 01110010 01100111 01100011 00101100 00100000 01100011  rgc, c
00000204: 01101000 01100001 01110010 00100000 00101010 00101010  har **
0000020a: 01100001 01110010 01100111 01110110 00101100 00100000  argv, 
00000210: 01101001 01101110 01110100 00100000 00101010 01100010  int *b
00000216: 01101001 01110100 01110011 00101001 00100000 01111011  its) {
0000021c: 00001010 00100000 00100000 01101001 01100110 00100000  .  if 
00000222: 00101000 01100001 01110010 01100111 01100011 00100000  (argc 
00000228: 00111110 00100000 00110010 00101001 00100000 01111011  > 2) {
0000022e: 00001010 00100000 00100000 00100000 00100000 01110000  .    p
00000234: 01110010 01101001 01101110 01110100 01100110 00101000  rintf(
0000023a: 00100010 01010101 01110011 01100001 01100111 01100101  "Usage
00000240: 00111010 00100000 00100101 01110011 00100000 01011011  : %s [
00000246: 00101101 01100010 01111100 00101101 01100010 01101001  -b|-bi
0000024c: 01110100 01110011 01011101 01011100 01101110 00100010  ts]\n"
00000252: 00101100 00100000 01100001 01110010 01100111 01110110  , argv
00000258: 01011011 00110000 01011101 00101001 00111011 00001010  [0]);.
0000025e: 00100000 00100000 00100000 00100000 01100101 01111000      ex
00000264: 01101001 01110100 00101000 01000010 01000001 01000100  it(BAD
0000026a: 01011111 01001110 01010101 01001101 01000010 01000101  _NUMBE
00000270: 01010010 01011111 01000001 01010010 01000111 01010011  R_ARGS
00000276: 00101001 00111011 00001010 00100000 00100000 01111101  );.  }
0000027c: 00001010 00001010 00100000 00100000 01101001 01100110  ..  if
00000282: 00100000 00101000 01100001 01110010 01100111 01100011   (argc
00000288: 00100000 00111101 00111101 00100000 00110010 00100000   == 2 
0000028e: 00100110 00100110 00001010 00100000 00100000 00100000  &&.   
00000294: 00100000 00100000 00100000 00101000 01110011 01110100     (st
0000029a: 01110010 01100011 01101101 01110000 00101000 01100001  rcmp(a
000002a0: 01110010 01100111 01110110 01011011 00110001 01011101  rgv[1]
000002a6: 00101100 00100000 00100010 00101101 01100010 00100010  , "-b"
000002ac: 00101001 00100000 00111101 00111101 00100000 00110000  ) == 0
000002b2: 00100000 01111100 01111100 00100000 01110011 01110100   || st
000002b8: 01110010 01100011 01101101 01110000 00101000 01100001  rcmp(a
000002be: 01110010 01100111 01110110 01011011 00110001 01011101  rgv[1]
000002c4: 00101100 00100000 00100010 00101101 01100010 01101001  , "-bi
000002ca: 01110100 01110011 00100010 00101001 00100000 00111101  ts") =
000002d0: 00111101 00100000 00110000 00101001 00101001 00100000  = 0)) 
000002d6: 01111011 00001010 00100000 00100000 00100000 00100000  {.    
000002dc: 00101010 01100010 01101001 01110100 01110011 00100000  *bits 
000002e2: 00111101 00100000 01010100 01010010 01010101 01000101  = TRUE
000002e8: 00111011 00001010 00100000 00100000 01111101 00100000  ;.  } 
000002ee: 01100101 01101100 01110011 01100101 00100000 01111011  else {
000002f4: 00001010 00100000 00100000 00100000 00100000 00101010  .    *
000002fa: 01100010 01101001 01110100 01110011 00100000 00111101  bits =
00000300: 00100000 01000110 01000001 01001100 01010011 01000101   FALSE
00000306: 00111011 00001010 00100000 00100000 01111101 00001010  ;.  }.
0000030c: 00001010 00100000 00100000 01110010 01100101 01110100  .  ret
00000312: 01110101 01110010 01101110 00100000 01110011 01110100  urn st
00000318: 01100100 01101001 01101110 00111011 00001010 01111101  din;.}
0000031e: 00001010 00001010 01110110 01101111 01101001 01100100  ..void
00000324: 00100000 01100010 01111001 01110100 01100101 01010100   byteT
0000032a: 01101111 01001000 01100101 01111000 00101000 01110101  oHex(u
00000330: 01101110 01110011 01101001 01100111 01101110 01100101  nsigne
00000336: 01100100 00100000 01100011 01101000 01100001 01110010  d char
0000033c: 00100000 01100100 01100001 01110100 01100001 00101001   data)
00000342: 00100000 01111011 00001010 00001001 01101001 01101110   {..in
00000348: 01110100 00100000 01100100 01101001 01100111 01101001  t digi
0000034e: 01110100 00110001 00100000 00111101 00100000 01100100  t1 = d
00000354: 01100001 01110100 01100001 00101111 00110001 00110110  ata/16
0000035a: 00111011 00001010 00001001 01101001 01100110 00100000  ;..if 
00000360: 00101000 01100100 01101001 01100111 01101001 01110100  (digit
00000366: 00110001 00100000 00111100 00100000 00110000 00101001  1 < 0)
0000036c: 00100000 01111011 00001010 00001001 00001001 01110000   {...p
00000372: 01110010 01101001 01101110 01110100 01100110 00101000  rintf(
00000378: 00100010 01100100 01100001 01110100 01100001 00100000  "data 
0000037e: 00100101 01100011 00101100 00100000 00100101 01100100  %c, %d
00000384: 00101100 00100000 01110000 01110010 01101111 01100100  , prod
0000038a: 01110101 01100011 01100101 01100100 00100000 01101111  uced o
00000390: 01110101 01110100 01110000 01110101 01110100 00100000  utput 
00000396: 01101100 01100101 01110011 01110011 00100000 01110100  less t
0000039c: 01101000 01100001 01101110 00100000 01111010 01100101  han ze
000003a2: 01110010 01101111 00101100 00100000 01100100 01101001  ro, di
000003a8: 01100111 01101001 01110100 00100000 00110001 00100000  git 1 
000003ae: 01110111 01100001 01110011 00100000 00100101 01100100  was %d
000003b4: 00100010 00101100 00100000 01100100 01100001 01110100  ", dat
000003ba: 01100001 00101100 00100000 01100100 01100001 01110100  a, dat
000003c0: 01100001 00101100 00100000 01100100 01101001 01100111  a, dig
000003c6: 01101001 01110100 00110001 00101001 00111011 00001010  it1);.
000003cc: 00001001 00001001 01100101 01111000 01101001 01110100  ..exit
000003d2: 00100000 00101000 00110000 00101001 00111011 00001010   (0);.
000003d8: 00001001 01111101 00001010 00001001 01100011 01101000  .}..ch
000003de: 01100001 01110010 00100000 01100011 01101000 01100001  ar cha
000003e4: 01110010 01100100 01101001 01100111 01101001 01110100  rdigit
000003ea: 00110001 00111011 00001010 00001001 01101001 01100110  1;..if
000003f0: 00100000 00101000 01100100 01101001 01100111 01101001   (digi
000003f6: 01110100 00110001 00100000 00111110 00100000 00111001  t1 > 9
000003fc: 00101001 00100000 01111011 00001010 00001001 00001001  ) {...
00000402: 01100011 01101000 01100001 01110010 01100100 01101001  chardi
00000408: 01100111 01101001 01110100 00110001 00100000 00111101  git1 =
0000040e: 00100000 01100100 01101001 01100111 01101001 01110100   digit
00000414: 00110001 00100000 00101011 00100000 00111000 00110111  1 + 87
0000041a: 00111011 00001010 00001001 00001001 01110000 01110010  ;...pr
00000420: 01101001 01101110 01110100 01100110 00101000 00100010  intf("
00000426: 00100101 01100011 00100010 00101100 00100000 01100011  %c", c
0000042c: 01101000 01100001 01110010 01100100 01101001 01100111  hardig
00000432: 01101001 01110100 00110001 00101001 00111011 00001010  it1);.
00000438: 00001001 01111101 00100000 01100101 01101100 01110011  .} els
0000043e: 01100101 00100000 01111011 00001010 00001001 00001001  e {...
00000444: 01110000 01110010 01101001 01101110 01110100 01100110  printf
0000044a: 00101000 00100010 00100101 01100100 00100010 00101100  ("%d",
00000450: 00100000 01100100 01101001 01100111 01101001 01110100   digit
00000456: 00110001 00101001 00111011 00001010 00001001 01111101  1);..}
0000045c: 00001010 00001001 01101001 01101110 01110100 00100000  ..int 
00000462: 01110010 01100101 01101101 01100001 01101001 01101110  remain
00000468: 01100100 01100101 01110010 00100000 00111101 00100000  der = 
0000046e: 01100100 01100001 01110100 01100001 00100101 00110001  data%1
00000474: 00110110 00111011 00001010 00001001 01101001 01101110  6;..in
0000047a: 01110100 00100000 01100100 01101001 01100111 01101001  t digi
00000480: 01110100 00110010 00100000 00111101 00100000 00110000  t2 = 0
00000486: 00111011 00001010 00001001 01100011 01101000 01100001  ;..cha
0000048c: 01110010 00100000 01100100 01101001 01100111 01101001  r digi
00000492: 01110100 00110010 01100011 01101000 01100001 01110010  t2char
00000498: 00111011 00001010 00001001 01101001 01100110 00100000  ;..if 
0000049e: 00101000 01110010 01100101 01101101 01100001 01101001  (remai
000004a4: 01101110 01100100 01100101 01110010 00100000 00111110  nder >
000004aa: 00100000 00111001 00101001 00100000 01111011 00001010   9) {.
000004b0: 00001001 00001001 01100100 01101001 01100111 01101001  ..digi
000004b6: 01110100 00110010 01100011 01101000 01100001 01110010  t2char
000004bc: 00100000 00111101 00100000 01110010 01100101 01101101   = rem
000004c2: 01100001 01101001 01101110 01100100 01100101 01110010  ainder
000004c8: 00100000 00101011 00100000 00111000 00110111 00111011   + 87;
000004ce: 00001010 00001001 00001001 01110000 01110010 01101001  ...pri
000004d4: 01101110 01110100 01100110 00101000 00100010 00100101  ntf("%
000004da: 01100011 00100010 00101100 00100000 01100100 01101001  c", di
000004e0: 01100111 01101001 01110100 00110010 01100011 01101000  git2ch
000004e6: 01100001 01110010 00101001 00111011 00001010 00001001  ar);..
000004ec: 01111101 00100000 01100101 01101100 01110011 01100101  } else
000004f2: 00100000 01111011 00001010 00001001 00001001 01100100   {...d
000004f8: 01101001 01100111 01101001 01110100 00110010 00100000  igit2 
000004fe: 00111101 00100000 01110010 01100101 01101101 01100001  = rema
00000504: 01101001 01101110 01100100 01100101 01110010 00111011  inder;
0000050a: 00001010 00001001 00001001 01110000 01110010 01101001  ...pri
00000510: 01101110 01110100 01100110 00101000 00100010 00100101  ntf("%
00000516: 01100100 00100010 00101100 00100000 01100100 01101001  d", di
0000051c: 01100111 01101001 01110100 00110010 00101001 00111011  git2);
00000522: 00001010 00001001 01111101 00001010 00001010 00001010  ..}...
00000528: 01111101 00001010 00101111 00101010 00101010 00001010  }./**.
0000052e: 00100000 00101010 00100000 01010111 01110010 01101001   * Wri
00000534: 01110100 01100101 01110011 00100000 01100100 01100001  tes da
0000053a: 01110100 01100001 00100000 01110100 01101111 00100000  ta to 
00000540: 01110011 01110100 01100100 01101111 01110101 01110100  stdout
00000546: 00100000 01101001 01101110 00100000 01101000 01100101   in he
0000054c: 01111000 01100001 01100100 01100101 01100011 01101001  xadeci
00000552: 01101101 01100001 01101100 00101110 00001010 00100000  mal.. 
00000558: 00101010 00001010 00100000 00101010 00100000 01010011  *. * S
0000055e: 01100101 01100101 00100000 01101101 01111001 01111000  ee myx
00000564: 01111000 01100100 00101110 01101101 01100100 00100000  xd.md 
0000056a: 01100110 01101111 01110010 00100000 01100100 01100101  for de
00000570: 01110100 01100001 01101001 01101100 01110011 00101110  tails.
00000576: 00001010 00100000 00101010 00001010 00100000 00101010  . *. *
0000057c: 00100000 01100100 01100001 01110100 01100001 00111010   data:
00000582: 00100000 01100001 01101110 00100000 01100001 01110010   an ar
00000588: 01110010 01100001 01111001 00100000 01101111 01100110  ray of
0000058e: 00100000 01101110 01101111 00100000 01101101 01101111   no mo
00000594: 01110010 01100101 00100000 01110100 01101000 01100001  re tha
0000059a: 01101110 00100000 00110001 00110110 00100000 01100011  n 16 c
000005a0: 01101000 01100001 01110010 01100001 01100011 01110100  haract
000005a6: 01100101 01110010 01110011 00001010 00100000 00101010  ers. *
000005ac: 00100000 01110011 01101001 01111010 01100101 00111010   size:
000005b2: 00100000 01110100 01101000 01100101 00100000 01110011   the s
000005b8: 01101001 01111010 01100101 00100000 01101111 01100110  ize of
000005be: 00100000 01110100 01101000 01100101 00100000 01100001   the a
000005c4: 01110010 01110010 01100001 01111001 00001010 00100000  rray. 
000005ca: 00101010 00101010 00101111 00001010 01110110 01101111  **/.vo
000005d0: 01101001 01100100 00100000 01110000 01110010 01101001  id pri
000005d6: 01101110 01110100 01000100 01100001 01110100 01100001  ntData
000005dc: 01000001 01110011 01001000 01100101 01111000 00101000  AsHex(
000005e2: 01110101 01101110 01110011 01101001 01100111 01101110  unsign
000005e8: 01100101 01100100 00100000 01100011 01101000 01100001  ed cha
000005ee: 01110010 00100000 00101010 01100100 01100001 01110100  r *dat
000005f4: 01100001 00101100 00100000 01110011 01101001 01111010  a, siz
000005fa: 01100101 01011111 01110100 00100000 01110011 01101001  e_t si
00000600: 01111010 01100101 00101001 00100000 01111011 00001010  ze) {.
00000606: 00001001 00101111 00101111 01110000 01110010 01101001  .//pri
0000060c: 01101110 01110100 01100110 00101000 00100010 01010100  ntf("T
00000612: 01001111 01000100 01001111 00100000 00110001 00111010  ODO 1:
00000618: 00100000 01110000 01110010 01101001 01101110 01110100   print
0000061e: 01000100 01100001 01110100 01100001 01000001 01110011  DataAs
00000624: 01001000 01100101 01111000 00100000 00101000 00110010  Hex (2
0000062a: 00101001 00100010 00101001 00111011 00001010 00001001  )");..
00000630: 00101111 00101111 01110000 01110010 01101001 01101110  //prin
00000636: 01110100 01100110 00101000 00100010 01110011 01101001  tf("si
0000063c: 01111010 01100101 00100000 01101001 01110011 00100000  ze is 
00000642: 00100101 01101100 01100100 00100010 00101100 00100000  %ld", 
00000648: 01110011 01101001 01111010 01100101 00101001 00111011  size);
0000064e: 00001010 00001001 01101001 01101110 01110100 00100000  ..int 
00000654: 01100011 01101111 01110101 01101110 01110100 01100101  counte
0000065a: 01110010 00100000 00111101 00100000 00110000 00111011  r = 0;
00000660: 00001010 00001001 01101001 01101110 01110100 00100000  ..int 
00000666: 01100010 01101100 01101111 01100011 01101011 01110011  blocks
0000066c: 00100000 00111101 00100000 00110000 00111011 00001010   = 0;.
00000672: 00001001 01100110 01101111 01110010 00100000 00101000  .for (
00000678: 01100011 01101111 01110101 01101110 01110100 01100101  counte
0000067e: 01110010 00111011 00100000 01100011 01101111 01110101  r; cou
00000684: 01101110 01110100 01100101 01110010 00100000 00111100  nter <
0000068a: 00100000 01110011 01101001 01111010 01100101 00111011   size;
00000690: 00100000 01100011 01101111 01110101 01101110 01110100   count
00000696: 01100101 01110010 00101011 00101011 00101001 00100000  er++) 
0000069c: 01111011 00001010 00001001 00001001 01101001 01100110  {...if
000006a2: 00100000 00101000 01100011 01101111 01110101 01101110   (coun
000006a8: 01110100 01100101 01110010 00100101 00110010 00100000  ter%2 
000006ae: 00111101 00111101 00100000 00110000 00101001 00100000  == 0) 
000006b4: 01111011 00001010 00001001 00001001 00001001 01110000  {....p
000006ba: 01110010 01101001 01101110 01110100 01100110 00101000  rintf(
000006c0: 00100010 00100000 00100010 00101001 00111011 00001010  " ");.
000006c6: 00001001 00001001 00001001 01100010 01101100 01101111  ...blo
000006cc: 01100011 01101011 01110011 00101011 00101011 00111011  cks++;
000006d2: 00001010 00001001 00001001 01111101 00001010 00001001  ...}..
000006d8: 00001001 01100010 01111001 01110100 01100101 01010100  .byteT
000006de: 01101111 01001000 01100101 01111000 00101000 01100100  oHex(d
000006e4: 01100001 01110100 01100001 01011011 01100011 01101111  ata[co
000006ea: 01110101 01101110 01110100 01100101 01110010 01011101  unter]
000006f0: 00101001 00111011 00001010 00001001 01111101 00001010  );..}.
000006f6: 00001001 01101001 01100110 00100000 00101000 01110011  .if (s
000006fc: 01101001 01111010 01100101 00100000 00111100 00100000  ize < 
00000702: 00110001 00110110 00101001 00100000 01111011 00001010  16) {.
00000708: 00001001 00001001 01101001 01101110 01110100 00100000  ..int 
0000070e: 01110010 01100101 01101101 01100001 01101001 01101110  remain
00000714: 01100100 01100101 01110010 00100000 00111101 00100000  der = 
0000071a: 00110001 00110110 00101101 01110011 01101001 01111010  16-siz
00000720: 01100101 00111011 00001010 00001001 00001001 01100110  e;...f
00000726: 01101111 01110010 00100000 00101000 01101001 01101110  or (in
0000072c: 01110100 00100000 01101001 00100000 00111101 00100000  t i = 
00000732: 00110000 00111011 00100000 01101001 00100000 00111100  0; i <
00000738: 00100000 01110010 01100101 01101101 01100001 01101001   remai
0000073e: 01101110 01100100 01100101 01110010 00111011 00100000  nder; 
00000744: 01101001 00101011 00101011 00101001 01111011 00001010  i++){.
0000074a: 00001001 00001001 00001001 01110000 01110010 01101001  ...pri
00000750: 01101110 01110100 01100110 00101000 00100010 00100000  ntf(" 
00000756: 00100000 00100010 00101001 00111011 00001010 00001001   ");..
0000075c: 00001001 01111101 00001010 00001001 00001001 01100110  .}...f
00000762: 01101111 01110010 00100000 00101000 01100010 01101100  or (bl
00000768: 01101111 01100011 01101011 01110011 00111011 00100000  ocks; 
0000076e: 01100010 01101100 01101111 01100011 01101011 01110011  blocks
00000774: 00100000 00111100 00100000 00111000 00111011 00100000   < 8; 
0000077a: 01100010 01101100 01101111 01100011 01101011 01110011  blocks
00000780: 00101011 00101011 00101001 01111011 00001010 00001001  ++){..
00000786: 00001001 00001001 01110000 01110010 01101001 01101110  ..prin
0000078c: 01110100 01100110 00101000 00100010 00100000 00100010  tf(" "
00000792: 00101001 00111011 00001010 00001001 00001001 01111101  );...}
00000798: 00001010 00001001 01111101 00001010 00001001 01110010  ..}..r
0000079e: 01100101 01110100 01110101 01110010 01101110 00111011  eturn;
000007a4: 00001010 01111101 00001010 00001010 00101111 00101010  .}../*
000007aa: 00101010 00001010 00100000 00101010 00100000 01010111  *. * W
000007b0: 01110010 01101001 01110100 01100101 01110011 00100000  rites 
000007b6: 01100100 01100001 01110100 01100001 00100000 01110100  data t
000007bc: 01101111 00100000 01110011 01110100 01100100 01101111  o stdo
000007c2: 01110101 01110100 00100000 01100001 01110011 00100000  ut as 
000007c8: 01100011 01101000 01100001 01110010 01100001 01100011  charac
000007ce: 01110100 01100101 01110010 01110011 00101110 00001010  ters..
000007d4: 00100000 00101010 00001010 00100000 00101010 00100000   *. * 
000007da: 01010011 01100101 01100101 00100000 01101101 01111001  See my
000007e0: 01111000 01111000 01100100 00101110 01101101 01100100  xxd.md
000007e6: 00100000 01100110 01101111 01110010 00100000 01100100   for d
000007ec: 01100101 01110100 01100001 01101001 01101100 01110011  etails
000007f2: 00101110 00001010 00100000 00101010 00001010 00100000  .. *. 
000007f8: 00101010 00100000 01100100 01100001 01110100 01100001  * data
000007fe: 00111010 00100000 01100001 01101110 00100000 01100001  : an a
00000804: 01110010 01110010 01100001 01111001 00100000 01101111  rray o
0000080a: 01100110 00100000 01101110 01101111 00100000 01101101  f no m
00000810: 01101111 01110010 01100101 00100000 01110100 01101000  ore th
00000816: 01100001 01101110 00100000 00110001 00110110 00100000  an 16 
0000081c: 01100011 01101000 01100001 01110010 01100001 01100011  charac
00000822: 01110100 01100101 01110010 01110011 00001010 00100000  ters. 
00000828: 00101010 00100000 01110011 01101001 01111010 01100101  * size
0000082e: 00111010 00100000 01110100 01101000 01100101 00100000  : the 
00000834: 01110011 01101001 01111010 01100101 00100000 01101111  size o
0000083a: 01100110 00100000 01110100 01101000 01100101 00100000  f the 
00000840: 01100001 01110010 01110010 01100001 01111001 00001010  array.
00000846: 00100000 00101010 00101010 00101111 00001010 01110110   **/.v
0000084c: 01101111 01101001 01100100 00100000 01110000 01110010  oid pr
00000852: 01101001 01101110 01110100 01000100 01100001 01110100  intDat
00000858: 01100001 01000001 01110011 01000011 01101000 01100001  aAsCha
0000085e: 01110010 01110011 00101000 01110101 01101110 01110011  rs(uns
00000864: 01101001 01100111 01101110 01100101 01100100 00100000  igned 
0000086a: 01100011 01101000 01100001 01110010 00100000 00101010  char *
00000870: 01100100 01100001 01110100 01100001 00101100 00100000  data, 
00000876: 01110011 01101001 01111010 01100101 01011111 01110100  size_t
0000087c: 00100000 01110011 01101001 01111010 01100101 00101001   size)
00000882: 00100000 01111011 00001010 00001001 00101111 00101111   {..//
00000888: 01110000 01110010 01101001 01101110 01110100 01100110  printf
0000088e: 00101000 00100010 01010100 01001111 01000100 01001111  ("TODO
00000894: 00100000 00110010 00111010 00100000 01110000 01110010   2: pr
0000089a: 01101001 01101110 01110100 01000100 01100001 01110100  intDat
000008a0: 01100001 01000001 01110011 01000011 01101000 01100001  aAsCha
000008a6: 01110010 01110011 00100000 00101000 00110011 00101001  rs (3)
000008ac: 00100010 00101001 00111011 00001010 00001001 01100110  ");..f
000008b2: 01101111 01110010 00100000 00101000 01101001 01101110  or (in
000008b8: 01110100 00100000 01101001 00100000 00111101 00100000  t i = 
000008be: 00110000 00111011 00100000 01101001 00100000 00111100  0; i <
000008c4: 00100000 01110011 01101001 01111010 01100101 00111011   size;
000008ca: 00100000 01101001 00100000 00101011 00101011 00101001   i ++)
000008d0: 00100000 01111011 00001010 00001001 00001001 01101001   {...i
000008d6: 01100110 00100000 00101000 01100100 01100001 01110100  f (dat
000008dc: 01100001 01011011 01101001 01011101 00100000 00111100  a[i] <
000008e2: 00100000 00110011 00110010 00100000 01111100 01111100   32 ||
000008e8: 00100000 01100100 01100001 01110100 01100001 01011011   data[
000008ee: 01101001 01011101 00100000 00111110 00100000 00110001  i] > 1
000008f4: 00110010 00110110 00101001 00100000 01111011 00001010  26) {.
000008fa: 00001001 00001001 00001001 01110000 01110010 01101001  ...pri
00000900: 01101110 01110100 01100110 00101000 00100010 00101110  ntf(".
00000906: 00100010 00101001 00111011 00001010 00001001 00001001  ");...
0000090c: 01111101 00100000 01100101 01101100 01110011 01100101  } else
00000912: 00100000 01111011 00001010 00001001 00001001 00001001   {....
00000918: 01110000 01110010 01101001 01101110 01110100 01100110  printf
0000091e: 00101000 00100010 00100101 01100011 00100010 00101100  ("%c",
00000924: 00100000 01100100 01100001 01110100 01100001 01011011   data[
0000092a: 01101001 01011101 00101001 00111011 00001010 00001001  i]);..
00000930: 00001001 01111101 00001010 00001010 00001001 01111101  .}...}
00000936: 00001010 00001010 00001001 01110010 01100101 01110100  ...ret
0000093c: 01110101 01110010 01101110 00111011 00001010 01111101  urn;.}
00000942: 00001010 00001010 01110110 01101111 01101001 01100100  ..void
00000948: 00100000 01110010 01100101 01100001 01100100 01000001   readA
0000094e: 01101110 01100100 01010000 01110010 01101001 01101110  ndPrin
00000954: 01110100 01001001 01101110 01110000 01110101 01110100  tInput
0000095a: 01000001 01110011 01001000 01100101 01111000 00101000  AsHex(
00000960: 01000110 01001001 01001100 01000101 00100000 00101010  FILE *
00000966: 01101001 01101110 01110000 01110101 01110100 00101001  input)
0000096c: 00100000 01111011 00001010 00001001 01110101 01101110   {..un
00000972: 01110011 01101001 01100111 01101110 01100101 01100100  signed
00000978: 00100000 01100011 01101000 01100001 01110010 00100000   char 
0000097e: 01100100 01100001 01110100 01100001 01011011 00110001  data[1
00000984: 00110110 01011101 00111011 00001010 00001001 01101001  6];..i
0000098a: 01101110 01110100 00100000 01101110 01110101 01101101  nt num
00000990: 01000010 01111001 01110100 01100101 01110011 01010010  BytesR
00000996: 01100101 01100001 01100100 00100000 00111101 00100000  ead = 
0000099c: 01100110 01110010 01100101 01100001 01100100 00101000  fread(
000009a2: 01100100 01100001 01110100 01100001 00101100 00100000  data, 
000009a8: 00110001 00101100 00100000 00110001 00110110 00101100  1, 16,
000009ae: 00100000 01101001 01101110 01110000 01110101 01110100   input
000009b4: 00101001 00111011 00001010 00001001 01110101 01101110  );..un
000009ba: 01110011 01101001 01100111 01101110 01100101 01100100  signed
000009c0: 00100000 01101001 01101110 01110100 00100000 01101111   int o
000009c6: 01100110 01100110 01110011 01100101 01110100 00100000  ffset 
000009cc: 00111101 00100000 00110000 00111011 00001010 00001001  = 0;..
000009d2: 01110111 01101000 01101001 01101100 01100101 00100000  while 
000009d8: 00101000 01101110 01110101 01101101 01000010 01111001  (numBy
000009de: 01110100 01100101 01110011 01010010 01100101 01100001  tesRea
000009e4: 01100100 00100000 00100001 00111101 00100000 00110000  d != 0
000009ea: 00101001 00100000 01111011 00001010 00001001 00001001  ) {...
000009f0: 01110000 01110010 01101001 01101110 01110100 01100110  printf
000009f6: 00101000 00100010 00100101 00110000 00111000 01111000  ("%08x
000009fc: 00111010 00100010 00101100 00100000 01101111 01100110  :", of
00000a02: 01100110 01110011 01100101 01110100 00101001 00111011  fset);
00000a08: 00001010 00001001 00001001 01101111 01100110 01100110  ...off
00000a0e: 01110011 01100101 01110100 00100000 00101011 00111101  set +=
00000a14: 00100000 01101110 01110101 01101101 01000010 01111001   numBy
00000a1a: 01110100 01100101 01110011 01010010 01100101 01100001  tesRea
00000a20: 01100100 00111011 00001010 00001001 00001001 01110000  d;...p
00000a26: 01110010 01101001 01101110 01110100 01000100 01100001  rintDa
00000a2c: 01110100 01100001 01000001 01110011 01001000 01100101  taAsHe
00000a32: 01111000 00101000 01100100 01100001 01110100 01100001  x(data
00000a38: 00101100 00100000 01101110 01110101 01101101 01000010  , numB
00000a3e: 01111001 01110100 01100101 01110011 01010010 01100101  ytesRe
00000a44: 01100001 01100100 00101001 00111011 00001010 00001001  ad);..
00000a4a: 00001001 01110000 01110010 01101001 01101110 01110100  .print
00000a50: 01100110 00101000 00100010 00100000 00100000 00100010  f("  "
00000a56: 00101001 00111011 00001010 00001001 00001001 01110000  );...p
00000a5c: 01110010 01101001 01101110 01110100 01000100 01100001  rintDa
00000a62: 01110100 01100001 01000001 01110011 01000011 01101000  taAsCh
00000a68: 01100001 01110010 01110011 00101000 01100100 01100001  ars(da
00000a6e: 01110100 01100001 00101100 00100000 01101110 01110101  ta, nu
00000a74: 01101101 01000010 01111001 01110100 01100101 01110011  mBytes
00000a7a: 01010010 01100101 01100001 01100100 00101001 00111011  Read);
00000a80: 00001010 00001001 00001001 01110000 01110010 01101001  ...pri
00000a86: 01101110 01110100 01100110 00101000 00100010 01011100  ntf("\
00000a8c: 01101110 00100010 00101001 00111011 00001010 00001001  n");..
00000a92: 00001001 01101110 01110101 01101101 01000010 01111001  .numBy
00000a98: 01110100 01100101 01110011 01010010 01100101 01100001  tesRea
00000a9e: 01100100 00100000 00111101 00100000 01100110 01110010  d = fr
00000aa4: 01100101 01100001 01100100 00101000 01100100 01100001  ead(da
00000aaa: 01110100 01100001 00101100 00100000 00110001 00101100  ta, 1,
00000ab0: 00100000 00110001 00110110 00101100 00100000 01101001   16, i
00000ab6: 01101110 01110000 01110101 01110100 00101001 00111011  nput);
00000abc: 00001010 00001001 01111101 00001010 01111101 00001010  ..}.}.
00000ac2: 00001010 01110110 01101111 01101001 01100100 00100000  .void 
00000ac8: 01110000 01110010 01101001 01101110 01110100 01000011  printC
00000ace: 01101000 01100001 01110010 01000001 01110011 01000010  harAsB
00000ad4: 01101001 01110100 01110011 00101000 01110101 01101110  its(un
00000ada: 01110011 01101001 01100111 01101110 01100101 01100100  signed
00000ae0: 00100000 01100011 01101000 01100001 01110010 00100000   char 
00000ae6: 01100100 01100001 01110100 01100001 00101001 01111011  data){
00000aec: 00001010 00001001 01100011 01101000 01100001 01110010  ..char
00000af2: 00100000 01100010 01101001 01101110 01100001 01110010   binar
00000af8: 01111001 01011011 00111000 01011101 00111011 00001010  y[8];.
00000afe: 00001001 01101001 01101110 01110100 00100000 01110100  .int t
00000b04: 01110010 01100001 01100011 01101011 01100101 01110010  racker
00000b0a: 00100000 00111101 00100000 00110111 00111011 00001010   = 7;.
00000b10: 00001001 01100110 01101111 01110010 00100000 00101000  .for (
00000b16: 01101001 01101110 01110100 00100000 01101001 00100000  int i 
00000b1c: 00111101 00100000 00110000 00111011 00100000 01101001  = 0; i
00000b22: 00100000 00111100 00100000 00111000 00111011 00100000   < 8; 
00000b28: 01101001 00101011 00101011 00101001 01111011 00001010  i++){.
00000b2e: 00001001 00001001 01101001 01100110 00100000 00101000  ..if (
00000b34: 01100100 01100001 01110100 01100001 00100000 00100101  data %
00000b3a: 00100000 00110010 00100000 00111101 00111101 00100000   2 == 
00000b40: 00110001 00101001 00100000 01111011 00001010 00001001  1) {..
00000b46: 00001001 00001001 01100010 01101001 01101110 01100001  ..bina
00000b4c: 01110010 01111001 01011011 01110100 01110010 01100001  ry[tra
00000b52: 01100011 01101011 01100101 01110010 01011101 00100000  cker] 
00000b58: 00111101 00100000 00110001 00111011 00001010 00001001  = 1;..
00000b5e: 00001001 01111101 00100000 01100101 01101100 01110011  .} els
00000b64: 01100101 00100000 01101001 01100110 00100000 00101000  e if (
00000b6a: 01100100 01100001 01110100 01100001 00100000 00100101  data %
00000b70: 00100000 00110010 00100000 00111101 00111101 00100000   2 == 
00000b76: 00110000 00101001 01111011 00001010 00001001 00001001  0){...
00000b7c: 00001001 01100010 01101001 01101110 01100001 01110010  .binar
00000b82: 01111001 01011011 01110100 01110010 01100001 01100011  y[trac
00000b88: 01101011 01100101 01110010 01011101 00100000 00111101  ker] =
00000b8e: 00100000 00110000 00111011 00001010 00001001 00001001   0;...
00000b94: 01111101 00100000 01100101 01101100 01110011 01100101  } else
00000b9a: 00100000 01111011 00001010 00001001 00001001 00001001   {....
00000ba0: 01110000 01110010 01101001 01101110 01110100 01100110  printf
00000ba6: 00101000 00100010 01011100 01101110 00100000 01100101  ("\n e
00000bac: 01111000 01100011 01110101 01110011 01100101 00100000  xcuse 
00000bb2: 01101101 01100101 00100000 01110111 01101000 01100001  me wha
00000bb8: 01110100 00100000 01011100 01101110 00100010 00101001  t \n")
00000bbe: 00111011 00001010 00001001 00001001 00001001 01100101  ;....e
00000bc4: 01111000 01101001 01110100 00101000 00110000 00101001  xit(0)
00000bca: 00111011 00001010 00001001 00001001 01111101 00001010  ;...}.
00000bd0: 00001001 00001001 01100100 01100001 01110100 01100001  ..data
00000bd6: 00100000 00111101 00100000 01100100 01100001 01110100   = dat
00000bdc: 01100001 00101111 00110010 00111011 00001010 00001001  a/2;..
00000be2: 00001001 01110100 01110010 01100001 01100011 01101011  .track
00000be8: 01100101 01110010 00101101 00101101 00111011 00001010  er--;.
00000bee: 00001001 01111101 00001010 00001001 01100110 01101111  .}..fo
00000bf4: 01110010 00100000 00101000 01101001 01101110 01110100  r (int
00000bfa: 00100000 01101001 00100000 00111101 00100000 00110000   i = 0
00000c00: 00111011 00100000 01101001 00100000 00111100 00100000  ; i < 
00000c06: 00111000 00111011 00100000 01101001 00101011 00101011  8; i++
00000c0c: 00101001 00100000 01111011 00001010 00001001 00001001  ) {...
00000c12: 01110000 01110010 01101001 01101110 01110100 01100110  printf
00000c18: 00101000 00100010 00100101 01100100 00100010 00101100  ("%d",
00000c1e: 00100000 01100010 01101001 01101110 01100001 01110010   binar
00000c24: 01111001 01011011 01101001 01011101 00101001 00111011  y[i]);
00000c2a: 00001010 00001001 01111101 00001010 00001001 01110010  ..}..r
00000c30: 01100101 01110100 01110101 01110010 01101110 00111011  eturn;
00000c36: 00001010 01111101 00001010 00001010 01110110 01101111  .}..vo
00000c3c: 01101001 01100100 00100000 01110000 01110010 01101001  id pri
00000c42: 01101110 01110100 01000100 01100001 01110100 01100001  ntData
00000c48: 01000001 01110011 01000010 01101001 01110100 01110011  AsBits
00000c4e: 00101000 01110101 01101110 01110011 01101001 01100111  (unsig
00000c54: 01101110 01100101 01100100 00100000 01100011 01101000  ned ch
00000c5a: 01100001 01110010 00101010 00100000 01100100 01100001  ar* da
00000c60: 01110100 01100001 00101100 00100000 01110011 01101001  ta, si
00000c66: 01111010 01100101 01011111 01110100 00100000 01110011  ze_t s
00000c6c: 01101001 01111010 01100101 00101001 00100000 01111011  ize) {
00000c72: 00001010 00001001 01101001 01101110 01110100 00100000  ..int 
00000c78: 01100011 01101111 01110101 01101110 01110100 01100101  counte
00000c7e: 01110010 00100000 00111101 00100000 00110000 00111011  r = 0;
00000c84: 00001010 00001001 01101001 01101110 01110100 00100000  ..int 
00000c8a: 01100010 01101100 01101111 01100011 01101011 01110011  blocks
00000c90: 00100000 00111101 00100000 00110000 00111011 00001010   = 0;.
00000c96: 00001001 01100110 01101111 01110010 00100000 00101000  .for (
00000c9c: 01100011 01101111 01110101 01101110 01110100 01100101  counte
00000ca2: 01110010 00111011 00100000 01100011 01101111 01110101  r; cou
00000ca8: 01101110 01110100 01100101 01110010 00100000 00111100  nter <
00000cae: 00100000 01110011 01101001 01111010 01100101 00111011   size;
00000cb4: 00100000 01100011 01101111 01110101 01101110 01110100   count
00000cba: 01100101 01110010 00101011 00101011 00101001 00100000  er++) 
00000cc0: 01111011 00001010 00001001 00001001 01110000 01110010  {...pr
00000cc6: 01101001 01101110 01110100 01100110 00101000 00100010  intf("
00000ccc: 00100000 00100010 00101001 00111011 00001010 00001001   ");..
00000cd2: 00001001 01110000 01110010 01101001 01101110 01110100  .print
00000cd8: 01000011 01101000 01100001 01110010 01000001 01110011  CharAs
00000cde: 01000010 01101001 01110100 01110011 00101000 01100100  Bits(d
00000ce4: 01100001 01110100 01100001 01011011 01100011 01101111  ata[co
00000cea: 01110101 01101110 01110100 01100101 01110010 01011101  unter]
00000cf0: 00101001 00111011 00001010 00001001 00001001 01100010  );...b
00000cf6: 01101100 01101111 01100011 01101011 01110011 00101011  locks+
00000cfc: 00101011 00111011 00001010 00001001 01111101 00001010  +;..}.
00000d02: 00001001 01101001 01100110 00100000 00101000 01110011  .if (s
00000d08: 01101001 01111010 01100101 00100000 00111100 00100000  ize < 
00000d0e: 00110110 00101001 00100000 01111011 00001010 00001001  6) {..
00000d14: 00001001 01101001 01101110 01110100 00100000 01110010  .int r
00000d1a: 01100101 01101101 01100001 01101001 01101110 01100100  emaind
00000d20: 01100101 01110010 00100000 00111101 00100000 00110110  er = 6
00000d26: 00101101 01110011 01101001 01111010 01100101 00111011  -size;
00000d2c: 00001010 00001001 00001001 01100110 01101111 01110010  ...for
00000d32: 00100000 00101000 01101001 01101110 01110100 00100000   (int 
00000d38: 01101001 00100000 00111101 00100000 00110000 00111011  i = 0;
00000d3e: 00100000 01101001 00100000 00111100 00100000 01110010   i < r
00000d44: 01100101 01101101 01100001 01101001 01101110 01100100  emaind
00000d4a: 01100101 01110010 00111011 00100000 01101001 00101011  er; i+
00000d50: 00101011 00101001 01111011 00001010 00001001 00001001  +){...
00000d56: 00001001 01110000 01110010 01101001 01101110 01110100  .print
00000d5c: 01100110 00101000 00100010 00100000 00100000 00100000  f("   
00000d62: 00100000 00100000 00100000 00100000 00100000 00100010       "
00000d68: 00101001 00111011 00001010 00001001 00001001 01111101  );...}
00000d6e: 00001010 00001001 00001001 01100110 01101111 01110010  ...for
00000d74: 00100000 00101000 01100010 01101100 01101111 01100011   (bloc
00000d7a: 01101011 01110011 00111011 00100000 01100010 01101100  ks; bl
00000d80: 01101111 01100011 01101011 01110011 00100000 00111100  ocks <
00000d86: 00100000 00110110 00111011 00100000 01100010 01101100   6; bl
00000d8c: 01101111 01100011 01101011 01110011 00101011 00101011  ocks++
00000d92: 00101001 01111011 00001010 00001001 00001001 00001001  ){....
00000d98: 01110000 01110010 01101001 01101110 01110100 01100110  printf
00000d9e: 00101000 00100010 00100000 00100010 00101001 00111011  (" ");
00000da4: 00001010 00001001 00001001 01111101 00001010 00001001  ...}..
00000daa: 01111101 00001010 00001001 01110010 01100101 01110100  }..ret
00000db0: 01110101 01110010 01101110 00111011 00001010 01111101  urn;.}
00000db6: 00001010 00001010 00101111 00101010 00101010 00001010  ../**.
00000dbc: 00100000 00101010 00100000 01000010 01101001 01110100   * Bit
00000dc2: 01110011 00100000 01101111 01110101 01110100 01110000  s outp
00000dc8: 01110101 01110100 00100000 01100110 01101111 01110010  ut for
00000dce: 00100000 01111000 01111000 01100100 00101110 00001010   xxd..
00000dd4: 00100000 00101010 00001010 00100000 00101010 00100000   *. * 
00000dda: 01010011 01100101 01100101 00100000 01101101 01111001  See my
00000de0: 01111000 01111000 01100100 00101110 01101101 01100100  xxd.md
00000de6: 00100000 01100110 01101111 01110010 00100000 01100100   for d
00000dec: 01100101 01110100 01100001 01101001 01101100 01110011  etails
00000df2: 00101110 00001010 00100000 00101010 00001010 00100000  .. *. 
00000df8: 00101010 00100000 01101001 01101110 01110000 01110101  * inpu
00000dfe: 01110100 00111010 00100000 01101001 01101110 01110000  t: inp
00000e04: 01110101 01110100 00100000 01110011 01110100 01110010  ut str
00000e0a: 01100101 01100001 01101101 00001010 00100000 00101010  eam. *
00000e10: 00101010 00101111 00001010 01110110 01101111 01101001  */.voi
00000e16: 01100100 00100000 01110010 01100101 01100001 01100100  d read
00000e1c: 01000001 01101110 01100100 01010000 01110010 01101001  AndPri
00000e22: 01101110 01110100 01001001 01101110 01110000 01110101  ntInpu
00000e28: 01110100 01000001 01110011 01000010 01101001 01110100  tAsBit
00000e2e: 01110011 00101000 01000110 01001001 01001100 01000101  s(FILE
00000e34: 00100000 00101010 01101001 01101110 01110000 01110101   *inpu
00000e3a: 01110100 00101001 00100000 01111011 00001010 00100000  t) {. 
00000e40: 00001001 00101111 00101111 01110000 01110010 01101001  .//pri
00000e46: 01101110 01110100 01100110 00101000 00100010 01010100  ntf("T
00000e4c: 01001111 01000100 01001111 00100000 00110011 00111010  ODO 3:
00000e52: 00100000 01110010 01100101 01100001 01100100 01000001   readA
00000e58: 01101110 01100100 01010000 01110010 01101001 01101110  ndPrin
00000e5e: 01110100 01001001 01101110 01110000 01110101 01110100  tInput
00000e64: 01000001 01110011 01000010 01101001 01110100 01110011  AsBits
00000e6a: 01011100 01101110 00100010 00101001 00111011 00001010  \n");.
00000e70: 00001001 01110101 01101110 01110011 01101001 01100111  .unsig
00000e76: 01101110 01100101 01100100 00100000 01100011 01101000  ned ch
00000e7c: 01100001 01110010 00100000 01100100 01100001 01110100  ar dat
00000e82: 01100001 01011011 00111000 01011101 00111011 00001010  a[8];.
00000e88: 00001001 01101001 01101110 01110100 00100000 01101110  .int n
00000e8e: 01110101 01101101 01000010 01111001 01110100 01100101  umByte
00000e94: 01110011 01010010 01100101 01100001 01100100 00100000  sRead 
00000e9a: 00111101 00100000 01100110 01110010 01100101 01100001  = frea
00000ea0: 01100100 00101000 01100100 01100001 01110100 01100001  d(data
00000ea6: 00101100 00100000 00110001 00101100 00100000 00110110  , 1, 6
00000eac: 00101100 00100000 01101001 01101110 01110000 01110101  , inpu
00000eb2: 01110100 00101001 00111011 00001010 00001001 01110101  t);..u
00000eb8: 01101110 01110011 01101001 01100111 01101110 01100101  nsigne
00000ebe: 01100100 00100000 01101001 01101110 01110100 00100000  d int 
00000ec4: 01101111 01100110 01100110 01110011 01100101 01110100  offset
00000eca: 00100000 00111101 00100000 00110000 00111011 00001010   = 0;.
00000ed0: 00001001 01110111 01101000 01101001 01101100 01100101  .while
00000ed6: 00100000 00101000 01101110 01110101 01101101 01000010   (numB
00000edc: 01111001 01110100 01100101 01110011 01010010 01100101  ytesRe
00000ee2: 01100001 01100100 00100000 00100001 00111101 00100000  ad != 
00000ee8: 00110000 00101001 00100000 01111011 00001010 00001001  0) {..
00000eee: 00001001 01110000 01110010 01101001 01101110 01110100  .print
00000ef4: 01100110 00101000 00100010 00100101 00110000 00111000  f("%08
00000efa: 01111000 00111010 00100010 00101100 00100000 01101111  x:", o
00000f00: 01100110 01100110 01110011 01100101 01110100 00101001  ffset)
00000f06: 00111011 00001010 00001001 00001001 01101111 01100110  ;...of
00000f0c: 01100110 01110011 01100101 01110100 00100000 00101011  fset +
00000f12: 00111101 00100000 01101110 01110101 01101101 01000010  = numB
00000f18: 01111001 01110100 01100101 01110011 01010010 01100101  ytesRe
00000f1e: 01100001 01100100 00111011 00001010 00001001 00001001  ad;...
00000f24: 01110000 01110010 01101001 01101110 01110100 01000100  printD
00000f2a: 01100001 01110100 01100001 01000001 01110011 01000010  ataAsB
00000f30: 01101001 01110100 01110011 00101000 01100100 01100001  its(da
00000f36: 01110100 01100001 00101100 00100000 01101110 01110101  ta, nu
00000f3c: 01101101 01000010 01111001 01110100 01100101 01110011  mBytes
00000f42: 01010010 01100101 01100001 01100100 00101001 00111011  Read);
00000f48: 00001010 00001001 00001001 01110000 01110010 01101001  ...pri
00000f4e: 01101110 01110100 01100110 00101000 00100010 00100000  ntf(" 
00000f54: 00100000 00100010 00101001 00111011 00001010 00001001   ");..
00000f5a: 00001001 01110000 01110010 01101001 01101110 01110100  .print
00000f60: 01000100 01100001 01110100 01100001 01000001 01110011  DataAs
00000f66: 01000011 01101000 01100001 01110010 01110011 00101000  Chars(
00000f6c: 01100100 01100001 01110100 01100001 00101100 00100000  data, 
00000f72: 01101110 01110101 01101101 01000010 01111001 01110100  numByt
00000f78: 01100101 01110011 01010010 01100101 01100001 01100100  esRead
00000f7e: 00101001 00111011 00001010 00001001 00001001 01110000  );...p
00000f84: 01110010 01101001 01101110 01110100 01100110 00101000  rintf(
00000f8a: 00100010 01011100 01101110 00100010 00101001 00111011  "\n");
00000f90: 00001010 00001001 00001001 01101110 01110101 01101101  ...num
00000f96: 01000010 01111001 01110100 01100101 01110011 01010010  BytesR
00000f9c: 01100101 01100001 01100100 00100000 00111101 00100000  ead = 
00000fa2: 01100110 01110010 01100101 01100001 01100100 00101000  fread(
00000fa8: 01100100 01100001 01110100 01100001 00101100 00100000  data, 
00000fae: 00110001 00101100 00100000 00110110 00101100 00100000  1, 6, 
00000fb4: 01101001 01101110 01110000 01110101 01110100 00101001  input)
00000fba: 00111011 00001010 00001001 01111101 00001010 01111101  ;..}.}
00000fc0: 00001010 00001010 01101001 01101110 01110100 00100000  ..int 
00000fc6: 01101101 01100001 01101001 01101110 00101000 01101001  main(i
00000fcc: 01101110 01110100 00100000 01100001 01110010 01100111  nt arg
00000fd2: 01100011 00101100 00100000 01100011 01101000 01100001  c, cha
00000fd8: 01110010 00100000 00101010 00101010 01100001 01110010  r **ar
00000fde: 01100111 01110110 00101001 00100000 01111011 00001010  gv) {.
00000fe4: 00001001 01101001 01101110 01110100 00100000 01100010  .int b
00000fea: 01101001 01110100 01110011 00100000 00111101 00100000  its = 
00000ff0: 01000110 01000001 01001100 01010011 01000101 00111011  FALSE;
00000ff6: 00001010 00001001 01000110 01001001 01001100 01000101  ..FILE
00000ffc: 00100000 00101010 01101001 01101110 01110000 01110101   *inpu
00001002: 01110100 00100000 00111101 00100000 01110000 01100001  t = pa
00001008: 01110010 01110011 01100101 01000011 01101111 01101101  rseCom
0000100e: 01101101 01100001 01101110 01100100 01001100 01101001  mandLi
00001014: 01101110 01100101 00101000 01100001 01110010 01100111  ne(arg
0000101a: 01100011 00101100 00100000 01100001 01110010 01100111  c, arg
00001020: 01110110 00101100 00100000 00100110 01100010 01101001  v, &bi
00001026: 01110100 01110011 00101001 00111011 00001010 00001010  ts);..
0000102c: 00001001 01101001 01100110 00100000 00101000 01100010  .if (b
00001032: 01101001 01110100 01110011 00100000 00111101 00111101  its ==
00001038: 00100000 01000110 01000001 01001100 01010011 01000101   FALSE
0000103e: 00101001 00100000 01111011 00001010 00001001 00001001  ) {...
00001044: 01110010 01100101 01100001 01100100 01000001 01101110  readAn
0000104a: 01100100 01010000 01110010 01101001 01101110 01110100  dPrint
00001050: 01001001 01101110 01110000 01110101 01110100 01000001  InputA
00001056: 01110011 01001000 01100101 01111000 00101000 01101001  sHex(i
0000105c: 01101110 01110000 01110101 01110100 00101001 00111011  nput);
00001062: 00001010 00001001 01111101 00100000 01100101 01101100  ..} el
00001068: 01110011 01100101 00100000 01111011 00001010 00001001  se {..
0000106e: 00001001 01110010 01100101 01100001 01100100 01000001  .readA
00001074: 01101110 01100100 01010000 01110010 01101001 01101110  ndPrin
0000107a: 01110100 01001001 01101110 01110000 01110101 01110100  tInput
00001080: 01000001 01110011 01000010 01101001 01110100 01110011  AsBits
00001086: 00101000 01101001 01101110 01110000 01110101 01110100  (input
0000108c: 00101001 00111011 00001010 00001001 01111101 00001010  );..}.
00001092: 00001001 01110010 01100101 01110100 01110101 01110010  .retur
00001098: 01101110 00100000 00110000 00111011 00001010 01111101  n 0;.}
0000109e: 00001010                                               .
